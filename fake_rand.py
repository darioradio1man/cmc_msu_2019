# Написать модуль, в котором будет две фальшивые функции: randrange() и randint(),
# которые принимают тек же параметры, что и настоящие. При каждом чётном по порядку вызове
# функция randint(a, b) возвращает a, при нечётном — b. Функция randrange() может принимать
# от 1 до 4 параметров. Четвёртый параметр она игнорирует, а начало диапазона a, конец диапазона
# b и шаг d интерпретирует так. Если при очередном вызове эти величины совпадают с предыдущим вызовом,
# то randrange() сперва работает как если бы возвращала очередной элемент range(), то есть сначала a,
# затем a+d и т. д., пока не доберётся до конца диапазона, после чего продолжает с начала диапазона
# (шаг при этом не сбивается, см. пример). Пустых диапазонов (когда знак шага не соответствует концам диапазона)
# во входных данных нет. Если же при очередном вызове значения a, b или d оказываются иными,
# процесс запускается с начала.


a, b, d = -1, -1, -1
res = a


def randrange(a1, *args):
    global a, b, d, res
    b1, d1 = -1, 1
    if len(args) != 0:
        b1, d1 = args[0], args[1]
    else:
        b1, a1 = a1, 0
    if (a, b, d) != (a1, b1, d1):
        a, b, d = a1, b1, d1
        res = a
        return res
    else:
        res += d
        if res < b and d > 0 or res > b and d < 0:
            return res
        else:
            res = a + res - b
            return res


counter = -1


def randint(a, b):
    global counter
    counter += 1
    if counter % 2 == 0:
        return a
    else:
        return b
